---
title: SHA-256算法
type: docs
---

![sha_1_bg](../../../voyager-10.jpg)
SHA-256属于 SHA-2 家族，是一种 安全单向哈希函数  
输入任意长度 → 输出 256 bit（32 字节）的“指纹”  
具有一切hash算的特性  
它的流程也是
> [!NOTE]
> 输入 → 填充 → 分块 → 压缩函数（主循环） → 拼接输出

最核心的是 压缩函数 F，它对每个 512 位块迭代 64 轮。

### 1. SHA-256 输入填充
- 对原始消息 M：
    - 添加一个 0x80（1000 0000）
    - 补 0 填满到 (长度 ≡ 448 mod 512)
    - 最后添加 64 位的大端序原消息长度 (bit)
例子：输入 "abc"(24 bit)  
最终填充后长度 = 512 bit(1完整块)
### 2. 分块（每512位一块）
- SHA-256 一次处理：
```text
16 个 32-bit 单元：W[0]~W[15]
```
- 但主循环需要 64 轮，所以扩展成：
```text
W[16]~W[63]
```
- 使用下面两个 σ 函数（小 sigma）：
```text
σ0(x) = ROTR^7(x) xor ROTR^18(x) xor SHR^3(x)
σ1(x) = ROTR^17(x) xor ROTR^19(x) xor SHR^10(x)
```
这时候的sigma用于扩展消息，提高扩散性

### 3. 压缩函数
- SHA-256是有8个初始变量，每个都有自己的hash值
```text
H0 = 6a09e667
H1 = bb67ae85
H2 = 3c6ef372
H3 = a54ff53a
H4 = 510e527f
H5 = 9b05688c
H6 = 1f83d9ab
H7 = 5be0cd19
```
- 每一块数据都会进行运算
```text
T1 = h + Σ1(e) + Ch(e,f,g) + K[i] + W[i]
T2 = Σ0(a) + Maj(a,b,c)

h = g
g = f
f = e
e = d + T1
d = c
c = b
b = a
a = T1 + T2
```

- 两个大 sigma（用于 a,e）
```text
Σ0(x) = ROTR^2(x) xor ROTR^13(x) xor ROTR^22(x)
Σ1(x) = ROTR^6(x) xor ROTR^11(x) xor ROTR^25(x)
```
- 使用到的两个逻辑函数
```text
Ch(x,y,z)  = (x & y) xor (~x & z)
Maj(x,y,z) = (x & y) xor (x & z) xor (y & z)
```
- 最终把我们8个经过运算的值给进行拼接然后返回出去
```text
H0 = H0 + a
H1 = H1 + b
...
H7 = H7 + h
```
---
逆向时候各位首先看加密长度(128长度)，再看栈里面的初始值，然后再加密的轮数是多少(64轮一块,如果你的数据很多快就很多轮了)
```text
6a09e667
bb67ae85
3c6ef372
a54ff53a
510e527f
9b05688c
1f83d9ab
5be0cd19
```


## 伪代码
```c
void sha256_transform(uint32_t state[8], const uint8_t data[64]) {
    uint32_t W[64];
    uint32_t a, b, c, d, e, f, g, h;

    // 1. 把 data 前 16 个字节转成 W[0..15]
    for (int i = 0; i < 16; i++) {
        W[i] = (data[4*i] << 24) |
               (data[4*i+1] << 16) |
               (data[4*i+2] << 8) |
               (data[4*i+3]);
    }

    // 2. 扩展到 64
    for (int i = 16; i < 64; i++) {
        uint32_t s0 = rotr(W[i-15], 7) ^ rotr(W[i-15], 18) ^ (W[i-15] >> 3);
        uint32_t s1 = rotr(W[i-2], 17) ^ rotr(W[i-2], 19) ^ (W[i-2] >> 10);
        W[i] = W[i-16] + s0 + W[i-7] + s1;
    }

    // 3. 初始化工作变量
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    f = state[5];
    g = state[6];
    h = state[7];

    // 4. 64轮
    for (int i = 0; i < 64; i++) {
        uint32_t S1 = rotr(e,6) ^ rotr(e,11) ^ rotr(e,25);
        uint32_t ch = (e & f) ^ ((~e) & g);
        uint32_t temp1 = h + S1 + ch + K[i] + W[i];
        uint32_t S0 = rotr(a,2) ^ rotr(a,13) ^ rotr(a,22);
        uint32_t maj = (a & b) ^ (a & c) ^ (b & c);
        uint32_t temp2 = S0 + maj;

        h = g;
        g = f;
        f = e;
        e = d + temp1;
        d = c;
        c = b;
        b = a;
        a = temp1 + temp2;
    }

    // 5. 加到 state
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
    state[5] += f;
    state[6] += g;
    state[7] += h;
}
```
